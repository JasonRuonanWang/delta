# #-*- Encoding: UTF-8 -*-
# # python -m unittest tests_analysis/compare_diagnostic_kernels_fluctana.py

# """
# Author: R. Kube

# unit test that compares the output of the diagnostic kernels in tasks_mpi
# to output from the flucana package.

# There are multiple tests in this file.
# * Comparison of the task_fft output to fft output from fluctana. We need to wiggle a bit since
#   fluctana has odd number of fourier coefficients by default. 

# * Compare cross_phase diagnostic kernel to fluctana

# * Compare cross_corr diagnostic kernel to fluctana

# * Compare cross_phase diagnostic kernel to fluctana


# """

# import unittest

# import numpy as np 
# from scipy.signal import get_window
# import json
# import timeit

# import sys

# from analysis.tasks_mpi import cross_phase, cross_corr, cross_power, coherence
# from analysis.task_fft import task_fft_scipy
# from analysis.channels import channel, channel_pair



# class test_cross_corr(unittest.TestCase):
#     def setUp(self):
#         """This method is called right before each test... method"""
#         #print("Setting up unit tests")


#     @classmethod
#     def setUpClass(cls):
#         print("Calling setUpClass")

#         cls._ch1 = channel("L", 11, 2)
#         cls._ch2 = channel("L", 9, 6)

#         # Define fft_params and instantiate task_fft object
#         with np.load("test_data/io_array_tr_s0001.npz") as df:
#             # Load transformed data, as generated by datareader
#             io_array_tr = df["io_array"]

#         print(f"Channel idx for {cls._ch1}: {cls._ch1.idx()}, {cls._ch2}: {cls._ch2.idx()}")

#         with open("tests_analysis/config_fft.json", "r") as df:
#             cls._config_fft = json.load(df)

#         cls._config_fft["fft_params"]["fsample"] = cls._config_fft["ECEI_cfg"]["SampleRate"] * 1e3
#         #clf._config_fft["fft_params"]["nfft"] = 512

#         win = get_window(cls._config_fft["fft_params"]["window"], cls._config_fft["fft_params"]["nfft"])
#         win_factor = (win**2).mean()
#         print(f"win_Factor = {win_factor}")

#         cls._config_fft["fft_params"]["win_factor"] = win_factor

#         my_fft = task_fft_scipy(10_000, cls._config_fft["fft_params"], normalize=True, detrend=True)
#         cls._fft_data = my_fft.do_fft_local(io_array_tr)


#     def test_cross_phase(self):
#         """compares output of cross_phase fluctana routine to output from
#            cross_phase diagnostic kernel"""

#         def cross_phase_rmc():
#             #import sys, os
#             #sys.path.append(os.pardir)
#             sys.path.append("/global/homes/r/rkube/repos/fluctana_rmc")
#             from fluctana import FluctAna, KstarEcei

#             # HOW TO RUN
#             # ./python3 check_correlation.py 10186 [15.9,16] ECEI_L1303 ECEI_L1403
#             shot = 18431 
#             trange = [-0.1, -0.08]
#             clist = [['ECEI_L1102'], ['ECEI_L0906']]

#             # call fluctana
#             A = FluctAna()

#             # add data
#             A.add_data(KstarEcei(shot=shot, clist=clist[0], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)
#             A.add_data(KstarEcei(shot=shot, clist=clist[1], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)

#             # do fft; full = 1 
#             A.fftbins(nfft=512, window='hann', overlap=0.5, detrend=1, full=1)
            
#             # calculate correlation using data sets done and dtwo. results are saved in A.Dlist[dtwo].val
#             A.cross_phase(done=0, dtwo=1)
#             return(A)


#         A = cross_phase_rmc()
#         # Call the diagnostic kernel
#         ch_it = [channel_pair(self._ch1, self._ch2)]
#         res, _ = cross_phase(self._fft_data, ch_it, self._config_fft["fft_params"], None)
#         res = np.squeeze(res)
#         self.assertTrue(np.linalg.norm(A.Dlist[1].val[0][1:] - res) / np.linalg.norm(res) < 512)



#     def test_cross_corr(self):
#         """Compares output of cross correlation from fluctana to
#            output from crosscorr diganostic kernel"""


#         def cross_corr_rmc():
#             sys.path.append("/global/homes/r/rkube/repos/fluctana_rmc")
#             from fluctana import FluctAna, KstarEcei

#             # HOW TO RUN
#             # ./python3 check_correlation.py 10186 [15.9,16] ECEI_L1303 ECEI_L1403
#             shot = 18431 
#             trange = [-0.1, -0.08]
#             clist = [['ECEI_L1102'], ['ECEI_L0906']]

#             # call fluctana
#             A = FluctAna()

#             # add data
#             A.add_data(KstarEcei(shot=shot, clist=clist[0], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)
#             A.add_data(KstarEcei(shot=shot, clist=clist[1], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)

#             # do fft; full = 1 
#             A.fftbins(nfft=512, window='hann', overlap=0.5, detrend=1, full=1)

#             # calculate correlation using data sets done and dtwo. results are saved in A.Dlist[dtwo].val
#             A.correlation(done=0, dtwo=1)
            
#             return(A)


#         A = cross_corr_rmc()
#         # Call the diagnostic kernel
#         ch_it = [channel_pair(self._ch1, self._ch2)]
#         res, _ = cross_corr(self._fft_data, ch_it, self._config_fft["fft_params"], None)
#         res = np.squeeze(res)

#         self.assertTrue( np.linalg.norm(A.Dlist[1].val[0][1:] - res * 128) / np.linalg.norm(res) < 512)



#     def test_cross_power(self):
#         """Compares output of cross_power from fluctana to output of
#         cross_power diagnostic kernel"""
        
#         def cross_power_rmc():
#             sys.path.append("/global/homes/r/rkube/repos/fluctana_rmc")
#             from fluctana import FluctAna, KstarEcei

#             # HOW TO RUN
#             # ./python3 check_correlation.py 10186 [15.9,16] ECEI_L1303 ECEI_L1403
#             shot = 18431 
#             trange = [-0.1, -0.08]
#             clist = [['ECEI_L1102'], ['ECEI_L0906']]

#             # call fluctana
#             A = FluctAna()

#             # add data
#             A.add_data(KstarEcei(shot=shot, clist=clist[0], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)
#             A.add_data(KstarEcei(shot=shot, clist=clist[1], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)

#             # do fft; full = 1 
#             A.fftbins(nfft=512, window='hann', overlap=0.5, detrend=1, full=1)
#             A.cross_power(done=0, dtwo=1)
            
#             return(A)


#         A = cross_power_rmc()
#         # Call the diagnostic kernel
#         ch_it = [channel_pair(self._ch1, self._ch2)]
#         res, _ = cross_power(self._fft_data, ch_it, self._config_fft["fft_params"], None)
#         res = np.squeeze(res)

#         self.assertTrue( np.linalg.norm(A.Dlist[1].val[0][1:] * 4 - res) / np.linalg.norm(res) < 1)



#     def test_coherence(self):
#         """Compares output of cross_power from fluctana to output of
#         cross_power diagnostic kernel"""
        
#         def cross_power_rmc():
#             sys.path.append("/global/homes/r/rkube/repos/fluctana_rmc")
#             from fluctana import FluctAna, KstarEcei

#             # HOW TO RUN
#             # ./python3 check_correlation.py 10186 [15.9,16] ECEI_L1303 ECEI_L1403
#             shot = 18431 
#             trange = [-0.1, -0.08]
#             clist = [['ECEI_L1102'], ['ECEI_L0906']]

#             # call fluctana
#             A = FluctAna()

#             # add data
#             A.add_data(KstarEcei(shot=shot, clist=clist[0], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)
#             A.add_data(KstarEcei(shot=shot, clist=clist[1], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)

#             # do fft; full = 1 
#             A.fftbins(nfft=512, window='hann', overlap=0.5, detrend=1, full=1)
#             A.coherence(done=0, dtwo=1)
            
#             return(A)


#         A = cross_power_rmc()
#         # Call the diagnostic kernel
#         ch_it = [channel_pair(self._ch1, self._ch2)]
#         res, _ = coherence(self._fft_data, ch_it, self._config_fft["fft_params"], None)
#         res = np.squeeze(res)

#         self.assertTrue( np.linalg.norm(A.Dlist[1].val[0][1:] - res) / np.linalg.norm(res) < 1)





#     def test_fft(self):
#         """Compares output of the fftbins routine to output of fft_task object"""
#         def fftbins(x, dt, nfft, window, overlap, do_detrend, full):
#             from scipy.signal import detrend
#             # IN : 1 x tnum data
#             # OUT : bins x faxis fftdata
#             tnum = len(x)
            
#             bins = int(np.fix((int(tnum/nfft) - overlap)/(1.0 - overlap)))
#             win = np.hanning(nfft)
#             #bins, win = fft_window(tnum, nfft, window, overlap)
#             win_factor = np.mean(win**2)  # window factors
#             print("***fftbins: win_factor = {0:f}".format(win_factor))

#             # make an x-axis #
#             ax = np.fft.fftfreq(nfft, d=dt) # full 0~fN -fN~-f1
#             if np.mod(nfft, 2) == 0:  # even nfft
#                 ax = np.hstack([ax[0:int(nfft/2)], -(ax[int(nfft/2)]), ax[int(nfft/2):nfft]])
#             if full == 1: # full shift to -fN ~ 0 ~ fN
#                 ax = np.fft.fftshift(ax)
#             else: # half 0~fN
#                 ax = ax[0:int(nfft/2+1)]

#             # make fftdata
#             if full == 1: # full shift to -fN ~ 0 ~ fN
#                 if np.mod(nfft, 2) == 0:  # even nfft
#                     fftdata = np.zeros((bins, nfft+1), dtype=np.complex_)
#                 else:  # odd nfft
#                     fftdata = np.zeros((bins, nfft), dtype=np.complex_)
#             else: # half 0 ~ fN
#                 fftdata = np.zeros((bins, int(nfft/2+1)), dtype=np.complex_)

#             for b in range(bins):
#                 idx1 = int(b*np.fix(nfft*(1 - overlap)))
#                 idx2 = idx1 + nfft
#                 #print("***bin {0:d}, idx1 = {1:d}, idx2 = {2:d}".format(b, idx1, idx2))

#                 sx = x[idx1:idx2]

#                 if do_detrend == 1:
#                     sx = detrend(sx, type='linear')
#                 sx = detrend(sx, type='constant')  # subtract mean
#                 sx = sx * win  # apply window function

#                 # get fft
#                 SX = np.fft.fft(sx, n=nfft)/nfft  # divide by the length
#                 if np.mod(nfft, 2) == 0:  # even nfft
#                     SX = np.hstack([SX[0:int(nfft/2)], np.conj(SX[int(nfft/2)]), SX[int(nfft/2):nfft]])
#                 if full == 1: # shift to -fN ~ 0 ~ fN
#                     SX = np.fft.fftshift(SX)
#                 else: # half 0 ~ fN
#                     SX = SX[0:int(nfft/2+1)]

#                 fftdata[b,:] = SX

#             return ax, fftdata, win_factor


        
#         def fft_rmc():
#             sys.path.append("/global/homes/r/rkube/repos/fluctana_rmc")
#             from fluctana import FluctAna, KstarEcei
#             shot = 18431 
#             trange = [-0.1, -0.08]
#             clist = [['ECEI_L1102'], ['ECEI_L0906']]

#             # call fluctana
#             A = FluctAna()

#             # add data
#             A.add_data(KstarEcei(shot=shot, clist=clist[0], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)
#             A.add_data(KstarEcei(shot=shot, clist=clist[1], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)
#             return(A)

#         A = fft_rmc()

#         ch1_fa = np.squeeze(A.Dlist[0].data)
#         ch1_ax, ch1_ft, win_factor = fftbins(ch1_fa, dt=2e-6, nfft=512, window="hann", overlap=0.5, do_detrend=1, full=1)

#         ch2_fa = np.squeeze(A.Dlist[1].data)
#         ch2_ax, ch2_ft, win_factor = fftbins(ch2_fa, dt=2e-6, nfft=512, window="hann", overlap=0.5, do_detrend=1, full=1)

#         self.assertTrue(np.linalg.norm(ch1_ft[:, 1:].mean(axis=0) - self._fft_data[self._ch1.idx(), :, :].mean(axis=1) * 0.5) / np.linalg.norm(self._fft_data[self._ch1.idx(), :, :].mean(axis=1)) < 16.0)
#         self.assertTrue(np.linalg.norm(ch2_ft[:, 1:].mean(axis=0) - self._fft_data[self._ch2.idx(), :, :].mean(axis=1) * 0.5) / np.linalg.norm(self._fft_data[self._ch2.idx(), :, :].mean(axis=1)) < 16.0)




# if __name__ == '__main__':
#     unittest.main()


# # End of file compare_diagnostic_kernels_fluctana