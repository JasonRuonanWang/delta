#-*- Encoding: UTF-8 -*-
# python -m unittest tests_analysis/test_analysis_cross_corr.py

"""
Author: R. Kube

unit test that compares the output of the cross_corr diagnostic kernel in tasks_mpi
to output from the flucana package.

Test results are 3 asserts.
The first two test whether the fft is done correctly. For this, test data
generated by generate_test_data.py is read in and fourier transformed using the task_fft class.
The outputs should be almost identical.

Second, we calculate the cross-correlation using the cross_corr kernel. The output
can be somewhat off the result in fluctana. (100-200 in relative units).
When looking at the plot (see the notebook test_analysis_cross_corr.ipynb), the results
should be visually identical.

Right now, there is also a factor of 128 floating around.
"""

import unittest

import numpy as np
#import matplotlib as mpl
# Dummy plots
#mpl.use("AGG")

from scipy.signal import get_window, detrend
import json
import timeit

import sys

from analysis.tasks_mpi import cross_corr
from analysis.task_fft import task_fft_scipy
from analysis.channels import channel, channel_pair


###############################################################################################
#
#            Run fluctana analysis
#
###############################################################################################


class test_cross_corr(unittest.TestCase):
    def test_results(self):

        def fftbins(x, dt, nfft, window, overlap, do_detrend, full):
            # IN : 1 x tnum data
            # OUT : bins x faxis fftdata
            tnum = len(x)
            
            bins = int(np.fix((int(tnum/nfft) - overlap)/(1.0 - overlap)))
            win = np.hanning(nfft)
            #bins, win = fft_window(tnum, nfft, window, overlap)
            win_factor = np.mean(win**2)  # window factors
            print("***fftbins: win_factor = {0:f}".format(win_factor))

            # make an x-axis #
            ax = np.fft.fftfreq(nfft, d=dt) # full 0~fN -fN~-f1
            if np.mod(nfft, 2) == 0:  # even nfft
                ax = np.hstack([ax[0:int(nfft/2)], -(ax[int(nfft/2)]), ax[int(nfft/2):nfft]])
            if full == 1: # full shift to -fN ~ 0 ~ fN
                ax = np.fft.fftshift(ax)
            else: # half 0~fN
                ax = ax[0:int(nfft/2+1)]

            # make fftdata
            if full == 1: # full shift to -fN ~ 0 ~ fN
                if np.mod(nfft, 2) == 0:  # even nfft
                    fftdata = np.zeros((bins, nfft+1), dtype=np.complex_)
                else:  # odd nfft
                    fftdata = np.zeros((bins, nfft), dtype=np.complex_)
            else: # half 0 ~ fN
                fftdata = np.zeros((bins, int(nfft/2+1)), dtype=np.complex_)

            for b in range(bins):
                idx1 = int(b*np.fix(nfft*(1 - overlap)))
                idx2 = idx1 + nfft
                #print("***bin {0:d}, idx1 = {1:d}, idx2 = {2:d}".format(b, idx1, idx2))

                sx = x[idx1:idx2]

                if do_detrend == 1:
                    sx = detrend(sx, type='linear')
                sx = detrend(sx, type='constant')  # subtract mean
                sx = sx * win  # apply window function

                # get fft
                SX = np.fft.fft(sx, n=nfft)/nfft  # divide by the length
                if np.mod(nfft, 2) == 0:  # even nfft
                    SX = np.hstack([SX[0:int(nfft/2)], np.conj(SX[int(nfft/2)]), SX[int(nfft/2):nfft]])
                if full == 1: # shift to -fN ~ 0 ~ fN
                    SX = np.fft.fftshift(SX)
                else: # half 0 ~ fN
                    SX = SX[0:int(nfft/2+1)]

                fftdata[b,:] = SX

            return ax, fftdata, win_factor

        def test_rmc():
            sys.path.append("/global/homes/r/rkube/repos/fluctana_rmc")
            from fluctana import FluctAna, KstarEcei

            # HOW TO RUN
            # ./python3 check_correlation.py 10186 [15.9,16] ECEI_L1303 ECEI_L1403
            shot = 18431 
            trange = [-0.1, -0.08]
            clist = [['ECEI_L1102'], ['ECEI_L0906']]

            # call fluctana
            A = FluctAna()

            # add data
            A.add_data(KstarEcei(shot=shot, clist=clist[0], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)
            A.add_data(KstarEcei(shot=shot, clist=clist[1], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)

            # list data
            A.list_data()

            # do fft; full = 1 
            A.fftbins(nfft=512,window='hann',overlap=0.5,detrend=0,full=1)

            # calculate correlation using data sets done and dtwo. results are saved in A.Dlist[dtwo].val
            A.correlation(done=0, dtwo=1)

            # plot the results; dnum = data set number, cnl = channel number list to plot
            #A.mplot(dnum=1,cnl=range(len(A.Dlist[1].clist)),type='val')
            
            return(A)


        tic = timeit.default_timer()
        A = test_rmc()
        toc = timeit.default_timer()

        print(f"Fluctana takes {(toc - tic):6.4f}s")

        L1102_fa = np.squeeze(A.Dlist[0].data)
        L1102_ax, L1102_ft, win_factor = fftbins(L1102_fa, dt=2e-6, nfft=512, window="hann", overlap=0.5, do_detrend=1, full=1)

        print(L1102_ft.shape)

        L0906_fa = np.squeeze(A.Dlist[1].data)
        L0906ax, L0906_ft, win_factor = fftbins(L0906_fa, dt=2e-6, nfft=512, window="hann", overlap=0.5, do_detrend=1, full=1)

        ################################################################################################################
        #
        #    Set up for distributed analysis
        #
        ################################################################################################################
        c1 = channel('L', 11, 2)
        c2 = channel('L', 9, 6)

        print("Channel 1: ", c1, ", idx = ", c1.idx())
        print("Channel 2: ", c2, ", idx = ", c2.idx())

        with np.load("test_data/io_array_tr_s0001.npz") as df:
            # Load transformed data, as generated by datareader
            io_array_tr = df["io_array"]
            print("io_array_tr.shape = ", io_array_tr.shape)


        print("io_array_tr.shape = ", io_array_tr.shape)
        print(f"Channel idx for {c1}: {c1.idx()}, {c2}: {c2.idx()}")


        with open("tests_analysis/config_fft.json", "r") as df:
            config_fft = json.load(df)

        config_fft["fft_params"]["fsample"] = config_fft["ECEI_cfg"]["SampleRate"] * 1e3
        config_fft["fft_params"]["nfft"] = 512

        win = get_window(config_fft["fft_params"]["window"], config_fft["fft_params"]["nfft"])
        win_factor = (win**2).mean()
        print(f"win_Factor = {win_factor}")

        config_fft["fft_params"]["win_factor"] = win_factor

        my_fft = task_fft_scipy(10_000, config_fft["fft_params"], normalize=True, detrend=True)
        fft_data = my_fft.do_fft_local(io_array_tr)


        assert(np.linalg.norm(io_array_tr[c1.idx(), :] - L1102_fa) / np.linalg.norm(L1102_fa) < 1e-6)
        assert(np.linalg.norm(io_array_tr[c2.idx(), :] - L0906_fa) / np.linalg.norm(L0906_fa) < 1e-6)


        # Call the 
        ch_it = [channel_pair(c1, c2)]
        res, _ = cross_corr(fft_data, ch_it, config_fft["fft_params"], None)
        res = np.squeeze(res)

        assert( np.linalg.norm(A.Dlist[1].val[0][1:] - res * 128) / np.linalg.norm(res) < 512)


if __name__ == '__main__':
    unittest.main()

# End of file test_analysis_cross_corr.py