#-*- Encoding: UTF-8 -*-

"""
Author: R. Kube

unit test that compares the output of the cross_corr diagnostic kernel in tasks_mpi
to output from the flucana package.

Test results are 3 asserts.
The first two test whether the fft is done correctly. For this, test data
generated by generate_test_data.py is read in and fourier transformed using the task_fft class.
The outputs should be almost identical.

Second, we calculate the cross-correlation using the cross_corr kernel. The output
can be somewhat off the result in fluctana. (100-200 in relative units).
When looking at the plot (see the notebook test_analysis_cross_corr.ipynb), the results
should be visually identical.

Right now, there is also a factor of 128 floating around.
"""


import numpy as np
#import matplotlib as mpl
# Dummy plots
#mpl.use("AGG")

from scipy.signal import get_window, detrend
import json
import timeit

import sys

from analysis.tasks_mpi import cross_corr
from analysis.task_fft import task_fft_scipy
from analysis.channels import channel, channel_pair


###############################################################################################
#
#            Run fluctana analysis
#
###############################################################################################

def test_rmc():
    sys.path.append("/global/homes/r/rkube/repos/fluctana_rmc")
    from fluctana import FluctAna, KstarEcei

    # HOW TO RUN
    # ./python3 check_correlation.py 10186 [15.9,16] ECEI_L1303 ECEI_L1403
    shot = 18431 
    trange = [-0.1, -0.08]
    clist = [['ECEI_L1102'], ['ECEI_L0906']]

    # call fluctana
    A = FluctAna()

    # add data
    A.add_data(KstarEcei(shot=shot, clist=clist[0], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)
    A.add_data(KstarEcei(shot=shot, clist=clist[1], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)

    # list data
    A.list_data()

    # do fft; full = 1 
    A.fftbins(nfft=512,window='hann',overlap=0.5,detrend=0,full=1)

    # calculate correlation using data sets done and dtwo. results are saved in A.Dlist[dtwo].val
    A.correlation(done=0, dtwo=1)

    # plot the results; dnum = data set number, cnl = channel number list to plot
    #A.mplot(dnum=1,cnl=range(len(A.Dlist[1].clist)),type='val')
    
    return(A)


tic = timeit.default_timer()
A = test_rmc()
toc = timeit.default_timer()

print(f"Fluctana takes {(toc - tic):6.4f}s")

################################################################################################################
#
#    Set up for distributed analysis
#
################################################################################################################
c1 = channel('L', 11, 2)
c2 = channel('L', 9, 6)

print("Channel 1: ", c1, ", idx = ", c1.idx())
print("Channel 2: ", c2, ", idx = ", c2.idx())

with np.load("../test_data/io_array_tr_s0001.npz") as df:
    # Load transformed data, as generated by datareader
    io_array_tr = df["io_array"]
    print("io_array_tr.shape = ", io_array_tr.shape)


print("io_array_tr.shape = ", io_array_tr.shape)
print(f"Channel idx for {c1}: {c1.idx()}, {c2}: {c2.idx()}")


with open("config_fft.json", "r") as df:
    config_fft = json.load(df)

config_fft["fft_params"]["fsample"] = config_fft["ECEI_cfg"]["SampleRate"] * 1e3
config_fft["fft_params"]["nfft"] = 512

win = get_window(config_fft["fft_params"]["window"], config_fft["fft_params"]["nfft"])
win_factor = (win**2).mean()
print(f"win_Factor = {win_factor}")

config_fft["fft_params"]["win_factor"] = win_factor

my_fft = task_fft_scipy(10_000, config_fft["fft_params"], normalize=True, detrend=True)
fft_data = my_fft.do_fft_local(io_array_tr)


assert(np.linalg.norm(io_array_tr[c1.idx(), :] - L1102_fa) / np.linalg.norm(L1102_fa) < 1e-6)
assert(np.linalg.norm(io_array_tr[c2.idx(), :] - L0906_fa) / np.linalg.norm(L0906_fa) < 1e-6)


# Call the 
ch_it = [channel_pair(c1, c2)]
res, _ = cross_corr(fft_data, ch_it, config_fft["fft_params"], None)
res = np.squeeze(res)

assert( np.linalg.norm(A.Dlist[1].val[0][1:] - res * 128) / np.linalg.norm(res) < 1024)

# End of file test_analysis_cross_corr.py