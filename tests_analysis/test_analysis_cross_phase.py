#-*- Encoding: UTF-8 -*-
# 

"""
Author: R. Kube

unit test that compares the output of the cross_phase diagnostic kernel in tasks_mpi
to output from the flucana package.

There is 1 test result in this unit test, checking for the relative norm
of the fluctana calculated crossphase to the kernel-calculated crossphase

"""

import unittest

import numpy as np 
from scipy.signal import get_window
import json
import timeit

import sys

from analysis.tasks_mpi import cross_phase
from analysis.task_fft import task_fft_scipy
from analysis.channels import channel, channel_pair



class test_cross_corr(unittest.TestCase):
    def test_results(self):

        def test_rmc():
            #import sys, os
            #sys.path.append(os.pardir)
            sys.path.append("/global/homes/r/rkube/repos/fluctana_rmc")
            from fluctana import FluctAna, KstarEcei

            # HOW TO RUN
            # ./python3 check_correlation.py 10186 [15.9,16] ECEI_L1303 ECEI_L1403

            shot = 18431 
            trange = [-0.1, -0.08]
            clist = [['ECEI_L1102'], ['ECEI_L0906']]

            # call fluctana
            A = FluctAna()

            # add data
            A.add_data(KstarEcei(shot=shot, clist=clist[0], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)
            A.add_data(KstarEcei(shot=shot, clist=clist[1], data_path='/global/cscratch1/sd/rkube/KSTAR/kstar_streaming/'), trange=trange, norm=1)

            # list data
            A.list_data()

            # do fft; full = 1 
            A.fftbins(nfft=512,window='hann',overlap=0.5,detrend=0,full=1)

            print(dir(A))
            
            # calculate correlation using data sets done and dtwo. results are saved in A.Dlist[dtwo].val
            A.cross_phase(done=0, dtwo=1)
            return(A)


        tic = timeit.default_timer()
        A = test_rmc()
        toc = timeit.default_timer()

        print(f"Fluctana takes {(toc - tic):6.4f}s")

        c1 = channel('L', 11, 2)
        c2 = channel('L', 9, 6)

        print("Channel 1: ", c1, ", idx = ", c1.idx())
        print("Channel 2: ", c2, ", idx = ", c2.idx())
            
        with np.load("test_data/io_array_tr_s0001.npz") as df:
            # Load transformed data, as generated by datareader
            io_array_tr = df["io_array"]
            print("io_array_tr.shape = ", io_array_tr.shape)

        print(f"Channel idx for {c1}: {c1.idx()}, {c2}: {c2.idx()}")

        with open("tests_analysis/config_fft.json", "r") as df:
            config_fft = json.load(df)

        config_fft["fft_params"]["fsample"] = config_fft["ECEI_cfg"]["SampleRate"] * 1e3
        config_fft["fft_params"]["nfft"] = 512

        win = get_window(config_fft["fft_params"]["window"], config_fft["fft_params"]["nfft"])
        win_factor = (win**2).mean()
        print(f"win_Factor = {win_factor}")


        config_fft["fft_params"]["win_factor"] = win_factor


        my_fft = task_fft_scipy(10_000, config_fft["fft_params"], normalize=True, detrend=True)
        fft_data = my_fft.do_fft_local(io_array_tr)

        # Call the 
        ch_it = [channel_pair(c1, c2)]
        res, _ = cross_phase(fft_data, ch_it, config_fft["fft_params"], None)
        res = np.squeeze(res)


        assert(np.linalg.norm(A.Dlist[1].val[0][1:] - res) / np.linalg.norm(res) < 512)


if __name__ == '__main__':
    unittest.main()
