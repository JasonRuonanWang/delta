# -*- Encoding: UTF-8 -*-

import timeit
import numpy as np

from scipy.signal import get_window
import json

import sys
sys.path.append("/global/homes/r/rkube/repos/delta")
from analysis.channels import channel, channel_pair

from analysis.tasks_mpi import cross_phase, cross_corr, cross_power, coherence
from analysis.task_fft import task_fft_scipy
from analysis.channels import channel, channel_pair


from diagnostics_cython import my_coherence_cy

"""
Compare the performance of the coherence kernel to an implementation in cython
"""


# Define fft_params and instantiate task_fft object
with np.load("/global/homes/r/rkube/repos/delta/test_data/io_array_tr_s0001.npz") as df:
    # Load transformed data, as generated by datareader
    io_array_tr = df["io_array"]

with open("/global/homes/r/rkube/repos/delta/tests_analysis/config_fft.json", "r") as df:
    config_fft = json.load(df)

config_fft["fft_params"]["fsample"] = config_fft["ECEI_cfg"]["SampleRate"] * 1e3

win = get_window(config_fft["fft_params"]["window"], config_fft["fft_params"]["nfft"])
win_factor = (win**2).mean()
print(f"win_Factor = {win_factor}")

config_fft["fft_params"]["win_factor"] = win_factor

my_fft = task_fft_scipy(10_000, config_fft["fft_params"], normalize=True, detrend=True)
fft_data = my_fft.do_fft_local(io_array_tr)



###################################################
# Generate channels to iterate over
ch_it = [channel_pair(channel("L", i, 1), channel("L", i, 2)) for i in range(1, 25)]
ch_it = ch_it + [channel_pair(channel("L", i, 1), channel("L", i, 3)) for i in range(1, 25)]
ch_it = ch_it + [channel_pair(channel("L", i, 1), channel("L", i, 4)) for i in range(1, 25)]
ch_it = ch_it + [channel_pair(channel("L", i, 1), channel("L", i, 4)) for i in range(1, 25)]
ch_it = ch_it + [channel_pair(channel("L", i, 1), channel("L", i, 5)) for i in range(1, 25)]
ch_it = ch_it + [channel_pair(channel("L", i, 1), channel("L", i, 6)) for i in range(1, 25)]
ch_it = ch_it + [channel_pair(channel("L", i, 1), channel("L", i, 7)) for i in range(1, 25)]
ch_it = ch_it + [channel_pair(channel("L", i, 1), channel("L", i, 8)) for i in range(1, 25)]


ch1_idx_arr = np.array([int(ch_pair.ch1.idx()) for ch_pair in ch_it], dtype=np.uint64)
ch2_idx_arr = np.array([int(ch_pair.ch2.idx()) for ch_pair in ch_it], dtype=np.uint64)


res_coherence_no = coherence(fft_data, ch_it, None, None)[0]
res_coherence_cy = my_coherence_cy(fft_data, ch1_idx_arr, ch2_idx_arr)
print(f"Distance: {np.linalg.norm(res_coherence_no - res_coherence_cy)}")


n_loop = 10

tic_no = timeit.default_timer()
for _ in range(n_loop):
    res_coherence_no = coherence(fft_data, ch_it, None, None)[0]
toc_no = timeit.default_timer()
print(f"Default implementation: {((toc_no - tic_no) / n_loop):6.4f}s")

tic_cy = timeit.default_timer()
for _ in range(n_loop):
    res_coherence_cy = my_coherence_cy(fft_data, ch1_idx_arr, ch2_idx_arr)
toc_cy = timeit.default_timer()
print(f"Cython implementation:{((toc_cy - tic_cy) / n_loop):6.4f}s")


# End of file performance_coherence.py